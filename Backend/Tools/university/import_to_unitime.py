# # Backend/Tools/university/import_to_unitime.py

# import os
# import sys
# import requests
# from pydantic import BaseModel, Field
# from typing import Optional, Any
# from typing import Type

# # --- Project Path Setup ---
# PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), "../../.."))
# if PROJECT_ROOT not in sys.path:
#     sys.path.append(PROJECT_ROOT)

# from Backend.tool_framework.base_tool import BaseTool

# # --- Pydantic Input Schema ---
# class ImportToUnitimeInput(BaseModel):
#     unitime_xml_data: str = Field(..., description="The complete XML data string to be imported into the Unitime system.")

# # --- Tool Class Definition ---
# class ImportToUnitimeTool(BaseTool):
#     """
#     A tool that takes XML data and sends it to the Unitime dataexchange API endpoint for processing.
#     """
#     name: str = "Import_Data_to_Unitime"
#     description: str = "Use this tool to import the final XML data generated by the AI model into the Unitime system."
#     # args_schema = ImportToUnitimeInput
#     args_schema: Type[BaseModel] = ImportToUnitimeInput
    
#     def _execute(self, unitime_xml_data: str) -> str:
#         print("\n" + "="*60)
#         print("--- VERIFICATION MODE: XML Received ---")
#         print("The agent is about to send the following XML to UniTime:")
#         print("\n")
#         print(unitime_xml_data) 
#         print("\n" + "="*60 + "\n")
        
#         return "SUCCESS: XML was generated and verified in VERIFICATION MODE. It was NOT sent to the real UniTime server."
#         # --- END VERIFICATION BLOCK ---

#         api_url = self.get_tool_config("UNITIME_API_URL")
#         api_key = self.get_tool_config("UNITIME_API_KEY")

#         if not api_url or not api_key:
#             return "Error: Unitime API URL or API Key is not configured in the environment."

#         headers = {
#             "Authorization": f"Bearer {api_key}",
#             "Content-Type": "application/xml"
#         }
#         try:
#             response = requests.post(api_url, data=unitime_xml_data.encode('utf-8'), headers=headers)
#             response.raise_for_status()  # This will raise an HTTPError for bad responses (4xx or 5xx)
#             return f"Successfully imported data to Unitime. Server response: {response.text}"
#         except requests.exceptions.HTTPError as http_err:
#             return f"Error: HTTP error occurred during Unitime import: {http_err} - Response: {http_err.response.text}"
#         except requests.exceptions.RequestException as req_err:
#             return f"Error: A critical request error occurred during Unitime import: {req_err}"


















# Backend/Tools/university/import_to_unitime.py

import os
import sys
import requests
from requests.auth import HTTPBasicAuth  # --- ADDED: Import for Basic Auth
from pydantic import BaseModel, Field
from typing import Optional, Any
from typing import Type

# --- Project Path Setup ---
PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), "../../.."))
if PROJECT_ROOT not in sys.path:
    sys.path.append(PROJECT_ROOT)

from Backend.tool_framework.base_tool import BaseTool

# --- Pydantic Input Schema ---
class ImportToUnitimeInput(BaseModel):
    unitime_xml_data: str = Field(..., description="The complete XML data string to be imported into the Unitime system.")

# --- Tool Class Definition ---
class ImportToUnitimeTool(BaseTool):
    """
    A tool that takes XML data and sends it to the UniTime dataexchange API endpoint for processing.
    """
    name: str = "Import_Data_to_Lnitime"
    description: str = "Use this tool to import the final XML data generated by the AI model into the UniTime system."
    args_schema: Type[BaseModel] = ImportToUnitimeInput
    
    def _execute(self, unitime_xml_data: str) -> str:
        
        # --- Load ALL necessary credentials from config ---
        api_url = self.get_tool_config("UNITIME_API_URL")
        username = self.get_tool_config("UNITIME_USERNAME") # --- ADDED ---
        password = self.get_tool_config("UNITIME_PASSWORD") # --- ADDED ---
        
        # --- UPDATED: Check for all required configs ---
        if not api_url or not username or not password:
            return "Error: Missing UNITIME_API_URL, UNITIME_USERNAME, or UNITIME_PASSWORD in the environment configuration."

        # --- UPDATED: Matched headers from your working test_api.py ---
        headers = {
            "Content-Type": "application/xml;charset=UTF-8"
        }
        
        try:
            print(f"--- ATTEMPTING TO POST XML TO {api_url} using Basic Auth ---")
            
            response = requests.post(
                api_url, 
                data=unitime_xml_data.encode('utf-8'), # Send the raw XML as bytes
                headers=headers,
                auth=HTTPBasicAuth(username, password) # --- ADDED: This is the critical fix
            )
            
            response.raise_for_status()  # This will raise an HTTPError for bad responses (4xx or 5xx)
            
            # If the server sends back HTML (like a success page), we might not want to print all of it.
            if "text/html" in response.headers.get("Content-Type", ""):
                 return f"Successfully imported data to UniTime. Server returned an HTML success page (Status: {response.status_code}). Server response: {response.text}"
            
            return f"Successfully imported data to UniTime. Server response: {response.text}"
        
        except requests.exceptions.HTTPError as http_err:
            # This will show you 401 (Unauthorized), 404, 500, 415 (Unsupported Media Type) errors
            return f"Error: HTTP error occurred during UniTime import: {http_err} - Response: {http_err.response.text}"
        except requests.exceptions.RequestException as req_err:
            # This will catch "Connection Refused" if the server is down
            return f"Error: A critical request error occurred: {req_err}"